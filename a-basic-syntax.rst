通用语法
=========

* `汇编预处理`_
* `空白和注释`_
* `符号和语句`_
* `字符常量`_
* `数值常量`_
* `程序分区`_
* `内部分区`_
* `链接分区`_
* `子级分区`_
* `符号名称`_
* `局部符号`_
* `符号属性`_
* `表达式`_

汇编预处理
----------

汇编内部的预处理器：

1. 调整和移除额外的空白，在关键字之前保留一个空格字符或tab字符，然后一行中的其他空白都
   会被换成一个空格
2. 移除掉所有的注释，替换成一个空格，或合适数量的换行符
3. 将字符常量转换成对应的数值

但是可以在文件中使用 #NO_APP 行和 #APP 行来关闭和打开移除空白和注释的功能，在 #NO_APP
行之后的空白和注释不会被移除，在 #APP 行之后的空白和注释会被移除。

汇编不会处理宏、文件包含、或任何其他 C 语言预处理的功能。但可以使用 .include 命令来包
含一个文件。对于 C 语言风格的预处理，可以将文件后缀命名为 .S，让 GCC 先跑一遍 C 的预处
理。

空白和注释
----------

空白是一个或多个空白字符或tab字符，用来分隔符号，让程序更容易阅读。除非在字符常量内部，
任何空白都与一个空格字符相同。

汇编代码中有两种方式的注释，一种是块注释 ``/* */``，不能嵌套，因为 ``/* /* */ */`` 遇
到第一个 ``*/`` 就认为注释结束了。另一种是行注释，行注释从行注释字符开始到下一个换行符
结束。行注释字符是平台相关的，并且一些平台还支持多种行注释字符。还有一些平台只支持将行注
释字符作为行的第一个字符使用，一些平台引入两个字符作为行注释的开始，一些平台还可以通过命
令行选项修改行注释字符。

如果行注释字符是 # 字符，但它还有特别的含义，例如上文提到的 #NO_APP、#APP、以及设置逻
辑行号。为了兼容旧版本，以 # 字符开始的行有特殊的解释，其后是一个绝对值表达式，表示下
一行的逻辑行号和逻辑文件名，但如果第一个非空白字符不是一个数值，会当作是一个注释。 ::

                                # 这是一个正常的注释
    # 42-6 "new_file_name"      # 新的逻辑文件名
                                # 这一行的逻辑行号是 36，因为 42 减 6 是 36

这个功能是过时的，在以后的版本种可能会被移除。

符号和语句
----------

符号是一个名称，有字母、数字、以及三个特殊字符（_.$）组成。在大多数平台上，可以将 $ 字
符用在符号名称中。符号不能以数字开头，并且是大小写敏感的，长度没有限制。符号名称还可以包
含在双引号内部，这种情况下，除NUL字符之外的任何字符都是允许的，如果包含双引号字符需要进
行转义。

一条语句用换行符或行分隔符结束，行分隔符是一个平台相关的字符，并不是所有的平台都支持行分
隔符。换行符或行分隔符被当作是当前语句的一部分。在字符常量中的换行符和分隔符是一个例外，
它们不是语句的结束符。

不能用 EOF 来作为语句的结束，文件的最后一个字符应该是一个换行符。一个空语句是允许的，并
且可以包含空白，空语句会被忽略。

一条语句以零个或多个标签开始，可选跟随一个关键符号，这个符号表示语句的类型，决定了语句剩
余部分的语法。如果这个符号以点号开始，这个语句是一个汇编命令。如果符号以字母开头，这个语
句是一个汇编语言指令，指令与平台相关，实际上一个相关的符号在不同的平台上可能代表不能的指
令。

标签是一个符号，后面跟一个冒号。空白出现在标签之前和冒号之后是允许的，但不能出现在标签的
符号和冒号之间。对于 HPPA 平台，空白可以出现在标签符号和冒号之间，但是符号必须顶行开
始，也意味着不能在一行定义多个标签。为了绕过这种限制，在 HPPA 平台上，提供 .label 命令
来定义标签。

语句的例子： ::

    label:      .directive  followed by somthing
    another_label:          # 这是一个空语句
                instruction operand_1, operand_2, ...

字符常量
--------

有两种字符常量，单个字符表示一个字节可以出现在数值表达式中，字符串常量可以有多个字节它不
能用在算术表达式中。

字符串包含在双引号之间，可以包含双引号和NUL字符。特殊字符需要使用反斜杠字符转义： ::

    \b          表示字符 010
    \f          表示字符 014
    \n          表示字符 012
    \r          表示字符 015
    \t          表示字符 011
    \\          表示反斜杠字符
    \"          表示双引号字符
    \ddd        八进制表示的字符，为了兼容其他 Unix 系统，
                允许出现8和9，例如 \009 的值是 011
    \xhhh...    十六进制表示的字符
    \<else>     会报警告，但相当于没有书写反斜杠

单个字符用一个单引号开始然后紧跟着对应的字符，紧跟的字符也可以是转义字符，再加上一个 \'
表示单引号字符，例如 '\\ 表示一个反斜杠字符。如果一个换行符紧跟在单引号之后，表示的是一
个换行字符常量，不会当作是一条语句的结束。

数值常量
---------

有三种数值常量，整数相当于 C 语言中的32位整型，bignum 是超过32位的整型，flonum 是浮点
数。二进制整型以 0b 或 0B 开始，八进制整型以 0 开始，十进制整型以非零的数字开始，十六
进制整型以 0x 或 0X 开始。大整型（bignum）与整型有相同的表示方法，区分两种类型是因为在
一些地方只能使用整型而不能使用大整型。

浮点数（flonum）的转换是间接的，十进制浮点数会被转换成超常精度的二进制浮点数，然后转换
成特定平台的浮点数格式。一个浮点数的写法如下（按顺序）：

1. 数字 0（在 HPPA 平台上可选）
2. 一个字母，表示该数字是一个浮点数，推荐使用字符 e（大小写无关）。在 HS/300，Renesas/
   SuperH SH 平台上，该字母必须是 'dfprsx' 中的一个。在 ARC 平台上，必须是 'dfrs'。
   在 HPPA 平台上必须是大写的 E
3. 一个可选的正负号
4. 一个可选的整数部分，零个或多个十进制数字
5. 一个可选的小数部分，以点字符开始后面跟随零个或多个十进制数字
6. 一个可选的指数部分，包含一个 E 或 e 字符，一个可选的正负号，一个或多个十进制数字

整数部分和小数部分必须至少存在一个。

常量的例子： ::

    .byte 74, 0112, 092, 0x4A, 0X4a, 'J, '\J # 都是同一个值
    .ascii "Ring the bell\7"                 # 字符串常量
    # 一个 bignum，word是2个字节，octa-word是16个字节
    .octa 0x123456789abcdef0123456789ABCDEF0
    .float 0f-314159265358979323846264338327\
    95028841971.693993751E-40                # 一个 flonum

数据类型： ::

    .ascii "Ring the bell\7"                    # 字符串
    .byte 74, 0112, 092, 0x4A, 0X4a, 'J, '\J    # 字符，单字节整数
    .2byte 23                                   # 双字节整数
    .4byte 34                                   # 四字节整数
    .8byte 45                                   # 八字节整数
    .quad 56                                    # 八字节整数，4*2（word）
    .octa 0x123456789abcdef0123456789ABCDEF0    # 16字节大整数，8*2（word)
    .float 0f-314.15926e-2                      # 浮点数
    .single 0f3.14                              # 单精度浮点，与.float相同
    .double 0f3.14                              # 双精度浮点
    hello_str: .asciz "hello world."    # 以零字节结尾的字符串
    hello_len: .4byte (. - hello_str)   # 变量名都是地址，特殊符号.表示当前地址
    self_addr: .4byte .                 # 一个保持自己地址的变量

常量操作数： ::

    movl $10,%eax
    movl $0xff,%eax
    movl $'A,%eax
    movl $(10 + 20),%eax
    movl $(2 * 3),%eax
    movl $((10 + 20) * 3),%eax

    .equ MAX_VALUE, 100
    .equ BASE, 100
    .equ OFFSET, 20

    movl $MAX_VALUE,%eax
    movl $(BASE + OFFSET),%eax

程序分区
---------

粗略地，一个分区是一个没有间隙的地址范围，这个范围内的所有数据以某种相同的特殊目的对待，
例如可能是一个只读的分区。链接器（ld）读取很多目标文件将它们合并成一个可执行的程序。当
汇编器输出目标文件时，该部分程序被假定起始地址为 0。链接器会为各个部分程序设置最终地
址，使得一个完整程序的各个部分不会重叠。这是一个很简化的说明，但是可以解释汇编器怎样使用
程序分区。

链接器将你的程序中的字节块移动到它们对应的运行时地址上，这些块像一个固定的单元一样滑动到
它们的运行时地址上，这个单元的长度不会改变，其中的字节顺序也不会改变。这样的一个固定单元
称为分区，为分区分配运行时地址称为重定位。分区可能会有填补以保证以特定地址边界结束。

汇编器输出的目标文件至少有三个分区，其中任何一个都可能为空，它们是代码区、数据区、以及未
初始化数据区（bss）。当它生成 COFF 或 ELF 格式的输出文件时，汇编器会出生成在汇编代码使
用 .section 命令指定其他名称的分区。如果没有使用任何命令将输出指定到 .text 或 .data 
分区，这些分区仍然存在，但是为空。在 HPPA 平台，当汇编器生成 SOM 或 ELF 文件时，还会生
成使用 .space 或 .subspace 命令指定的其他名称的分区。另外，当生成 SOM 格式文件时，标
准的代码、数据、以及未初始化数据分区有不同的名字，它们是 $CODE$、$DATA$、$BSS$。

在目标文件中，代码分区从零地址开始，然后跟随数据分区，未初始化数据分区跟在数据分区之后。
在 HPPA 平台上，生成 SOM 或 ELF 格式文件时，代码分区从零地址开始，数据分区从 
0x4000000 开始，未初始化数据分区跟随在数据分区之后。

为了使链接器知道当分区重定位时哪些数据需要修改，以及怎样修改这些数据，汇编器需要将重定位
的详细细节写入目标文件。为了执行重定位，目标文件中每次提及一个地址时，链接器必须知道：

1. 这个地址是从目标文件哪个地方开始
2. 这个地址引用的字节长度
3. 这个地址属于哪个分区，以及地址相对分区的偏移，即（地址）-（分区起始地址）的值是多少
4. 这个引用是一个程序计数相关的地址吗

实际上，汇编器已经使用过的每一个地址都表达为（分区）+（偏移）。而且，汇编器计算的大多数
表达式都使用这种相对于分区的表达形式。对于一些目标格式，例如 HPPA 平台的 SOM 格式，一
些表达式使用相对于符号的表达形式。

在这种形式下，我们使用 {secname N} 来表示相对于名为 secname 的分区偏移 N 个字节。除了
代码、数据、未初始化数据分区，还有一个绝对分区（absolute）必须了解。当链接器合并目标文
件时，绝对分区中的地址保持不变。例如，地址 {absolute 0} 被重定位到运行时地址 0。尽管链
接器绝不会为两个部分程序的目标文件的数据分区分配重合的地址，然而根据定义，它们的绝对分区
必定时重合的。两个目标文件中的地址 {absolute 239} 在运行时总是相同的。

还有一个未定义分区，当一个地址的分区在汇编时是未知的，会被定义成 {undefined U}，其中的
U 会在之后填充。因为数值总是定义的，唯一生成未定义地址的方式是提及一个未定义的符号。对
一个命名通用块（common block）中的一个引用就是这样的符号，它的值在汇编时是未知的，因此
它被归为未定义分区。

当链接程序时，链接器会将所有目标文件中的代码分区合并到一个连续的地址范围中，最后形成链接
完成的程序的代码分区。数据分区以及未初始化数据分区的处理也一样。

未初始化数据分区的内容，在程序执行前会被初始化为全零。使用 .lcomm 伪操作可以在 BSS 分
区中定义一个符号。而使用 .comm 伪操作可以用来顶一个通用符号，这是另一种形式的未初始化符
号。

当对一个支持多分区的目标格式进行汇编时，例如 ELF 或者 COFF，你可以使用 .section 命令切
换到 .bss 分区正常定义符号，你只能组装零值到这个分区。通常这个分区只能包含符号定义以及
.skip 命令。

内部分区
---------

还有一些汇编器内部使用的分区，这些分区只在汇编时有意义。在大多情况下，你不需要了解这些分
区，但它们在汇编器警告消息中会被提及。这些分区允许汇编语言程序中的每个表达式的值用相对于
分区的地址形式表示。

ASSEMBLER-INTERNAL-LOGIC-ERROR!
    出现了一个汇编器内部逻辑错误，表示汇编器有错误缺陷
expr section
    汇编器内部将复杂表达式作为符号组合存储在该分区中。当汇编器需要将一个表达式表示成一
    个符号时，它会将表达式放到表达式分区中

链接分区
---------

链接器只会处理四种分区：

named sections, text section, data section
    这些分区包含你的程序，汇编器和链接器将它们对待成分离的但是相同的分区。当程序运行
    时，唯一的不同点时，不允许对代码分区进行修改。代码分区通常在进程间共享，它包含指
    令、以及常量等。运行程序的数据区通常是可修改的，例如 C 语言的变量保持在数据区。
bss section
    该分区包含全零的数据，通常是未出世化的变量或者存储通用符号块。因为 bss 分区的内容总
    是全零，因此该分区不需要保存在目标文件中，不需要占据目标文件的空间。
absolute section
    该分区的地址 0 总是重定位到运行时的地址 0。如果引用的一个地址不想被链接器在处理重定
    位时修改，可以使用这个分区。也就是绝对地址是不可以重定位的。
undefined section
    这个逻辑上的分区用来捕获对未出现过的目标地址的引用，即这个目标在前面的分区中不存在

目标文件链接的示意图： ::

    部分程序 #1：
    text                data       bss
    |   ttttt           |  dddd    | 00 |

    部分程序 #2：
    text   data      bss
    | TTT  | DDDD    | 000 |

    链接后的程序：
        text                            data                 bss
    |   | TTT  |   ttttt           |    |  dddd    | DDDD    | 00000 |...

子级分区
---------

汇编后的数据字节最终会保存到两个分区：代码分区和数据分区。但是，你可以使用分隔的一组位于
命名分区中的数据，它们可以在目标文件中相互靠近的保存，即使它们在汇编代码中并不是连续的。
使用子级分区可以达到这个目的，一个分区可以有标号 0 到标号 8192 的子级分区。多个目标文件
中的相同子级分区中的内容会汇总到同一个同名的子级分区中。例如一个编译器可能想将所有的常量
放在在一起保存在代码分区，而不是穿插分散在程序的各个部分。子级分区是可选的，如果你不使用
子级分区，分区所有的内容都位于标号为 0 的子级分区中。

每个子级分区都会被填补零以达到 4 字节长度的整数倍。子级分区在目标文件中以标号从低到高排
列，目标文件不存储子级分区的表示，解析目标文件的链接器或其他工具不知道子级分区的存在。存
在的只有一个代码分区和一个数据分区。

子级分区的表示方法是分区名后加一个数值参数，如 ``.text expression``。当生成 COFF 格式
文件时，也可以使用 ``.section name, expression``。生成 ELF 格式文件时，可以使用
``.subsection expression``。上面的表达式 expression 必须是一个绝对值表达式。另外，不
使用标号的分区相当于标号为0的子级分区。例如 ``.text`` 相当于 ``.text 0``， ``.data``
相当于 ``.data 0``。

子级分区的例子： ::

    .text 0
    .ascii "当前位于第一个代码子级分区*"
    .text 1
    .ascii "当前位于第二个代码子级分区"
    .data 0
    .ascii "当前位于数据分区"
    .ascii "也是第一个数据子级分区"
    .text 0
    .ascii "当前位于第一个代码子级分区"
    .ascii "这个子级分区紧随在上面标*的子级分区之后"

每个分区都有一个位置计数，会对每个汇编到分区的字节计数。因为子级分区仅仅是汇编器的一个概
念分区，它不存在位置计数。没有直接操作位置计数的方法，但是 .align 命令可以改变这个值，
并且任何一个标签的定义都会获取到当前的位置计数。当前的位置计数如果有语句正在被汇编，称为
活动的位置计数。

符号名称
--------

符号是一个重要概念，程序使用符号来命名事物，链接器使用符号进行连接，调试器使用符号来调
试。注意，汇编器如果不按符号定义的顺序将符号保存到目标文件中，可能破坏一些调试器的解析。

一个标签是一个符号，后面跟随一个冒号。标签的符号表示活动位置计数当前的值，也即该符号可以
作为指令的操作数使用。如果定义了两个相同的标签，但是对应不同的位置计数，那么会产生一个警
告，然后第一个标签会覆盖后面的定义。

符号可以赋予任意的值，写法是在符号之后跟随一个等号，然后一个表达式。这等价于使用 .set
汇编命令。类似的，使用两个等号等价于使用 .eqv 汇编命令。Blackfin 平台不支持符号的等号
赋值。

符号名称以字母、或点号、或下划线开头，然后跟数字、字母、下划线、$ 字符。使用 $ 字符在大
多数平台上都支持，但是如果不支持就能使用。使用双引号引起的符号名不受这种限制，可以使用转
义字符，但当前只支持转义反斜杠和双引号。

名称是大小写敏感的，名称不能以数字开头，但是局部标签是一个例外。允许使用多字节字符，但是
设置 multibyte-handling 选项可能禁止这个功能。

特殊的点字符符号，表示汇编器汇编的当前地址。因此，表达式 ``melvin: .long .`` 定义一个
melvin 标签包含它自己的地址。给点字符符号赋值，相当于是一个 .org 命令，因此表达式
``.=.+4`` 相当于 ``.space 4``。

局部符号
---------

局部符号是以特殊局部标签前缀开始的符号，默认的局部标签前缀是 .L（ELF 系统）或者 L（传统
的 a.out 系统），但具体平台可能定义自己的局部标签前缀。在 HPPA 平台上，局部符号用 L$ 
开头。局部符号定义和使用在汇编器内部，通常不会保存到目标文件中，因此它们对于调试器是不见
的。你可以使用 -L 选项保留这些局部符号。

局部标签不同于局部符号，局部标签辅助编译器和程序员使用临时名称。局部标签创建一个保证在当
前整个源文件作用域中唯一的符号，并且可以使用简单的方法进行引用。使用 N: 的形式定义这种
局部标签，其中 N 是任意非负整数。引用前一个这种符号的定义，使用 Nb，其中 b 代表 
backwards。引用后一个这种符号的定义，使用 Nf，其中 f 代表 forwards。

怎样使用这些局部标签没有什么限制，而且可以重复定义相同名字的局部标签。另外注意，前10个
局部标签 0: 到 9: 比其他局部标签实现得更高效。下面是一个局部标签得例子： ::

    1:          branch 1f
    2:          branch 1b
    1:          branch 2f
    2:          branch 1b

    等价于：
    label_1:    branch label_3
    label_2:    branch label_1
    label_3:    branch label_4
    label_4:    branch label_3

局部标签仅仅是一个辅助记号，它们会在汇编器使用它们之前立即转换成传统的符号名称。符号会保
存在符号表中，出现在错误消息中，还可能保存到目标文件中。这些局部标签的实际名称由下面几部
分组成：

1. 局部标签前缀：所有局部符号都以特定平台规定的局部标签前缀开始。通常，汇编器和链接器会
   遗忘使用过的以局部标签前缀开始的符号，不会出现在目标文件中，除非使用 -L 选项让汇编器
   将它们保存到目标文件中，你也可以让链接器保留这些符号这样你才能在调试阶段看到它们
2. 数字：即局部标签定义时的那个整数
3. C-B：特殊的字符，其值为 \002（ctrl-B）
4. 局部标签的序列号：例如 0: 的第一个定义序列号为 1，第15个定义序列号为 15

因此，第一个 1: 局部标签的定义，它实际的名称可能为 .L1C-B1，第44个 3: 局部标签的定义的
实际名称可能是 .L3C-B44。

一些平台还支持更局部的标签称为 $ 字符标签，这些标签遇到一个非局部标签之后立即变成一个未
定义标签，因此它们只在一个很小的范围内合法。而一般的局部标签在整个文件作用域内都是合法
的，或者直到被另一个同名的局部标签重定义。

跟一般的局部标签定义一样，$ 字符标签只是在整数之后加了一个 $ 字符，例如 55$:。而这种局
部标签的实际名称使用的特殊字符是 C-A，它的值为 \001（ctrl-A）。例如，6$: 的第 5 个定
义，它实际名称可能是 .L6C-A5。

符号属性
---------

每个符号都有自己的值和类型，根据输出目标格式的不同，符号可能还有辅助属性。如果你使用一个
未定义的符号，汇编器假设这个符号所有的属性都为零，并且可能不会报警告。这种符号会被认为是
一个外部定义的符号。

符号的值通常是32位。对于引用 text，data，bss，或 absolute 分区中某个位置的符号，它的
值是该位置相对分区的偏移。当链接器进行链接时会修改分区基地址，同时这些符号值也跟着需要改
变。但是绝对值符号的值在链接时是不改变的，这也是它们被称为绝对值的原因。

未定义符号的值被特殊对待，如果是 0 表示这个符号没有定义在这个汇编源文件中。之后链接器会
尝试在链接到同一个程序的其他目标文件中查找这个符号的定义。如果未定义符号的值是非零，则表
示是一个 .comm 命令定义的通用声明，对应的非零值是该通用块的大小，最后符号引用的是该通用
块分配后的第一个字节的地址。

符号的类型属性包含重定位信息，任何设置的标志表示符号是外部符号，或链接器和调试器需要的其
他信息。具体的格式与目标代码使用的输出格式相关。

目标文件 COFF 格式支持多种辅助符号属性，符号的名称使用 .def 命令设置，符号的值和类型使
用 .val 和 .type 命令设置。另外 .dim，.line，.scl，.size，.tag，以及 .weak 可以生成
辅助符号表信息。

表达式
-------

一个表达式用来指定一个地址或者一个数值。空白可以出现在表达式之前或之后。一个表达式的结果
必须是一个绝对值，或者是一个相对于特定分区的偏移。如果表达式不是一个绝对值，而且汇编器在
遇到表达式时没有足够的信息知道它的分区，这种情况下可能需要对源代码进行二次解析。但是当前
并没有实现这种二次解析，因此汇编器在这种情况下会终止并抛出错误消息。

一个空表达式没有值，它仅仅是一个空白或者空值。在一个需要绝对表达式的地方，可以忽略表达、
式，此时汇编器假设这个绝对值是 0。

整型表达式是使用操作符分隔的一个或多个参数，其中参数是符号、数值、或子表达式。在其他上下
文中，参数也被叫做算术操作数。在这个手册中，我们使用参数这个名称，避免与机器指令操作数混
淆。操作数仅用来唯一的表示机器指令的操作数。

符号参数被求值用于产生 {section NNN} 的地址，其中 section 是 text、data、bss、
absolute、或者 undefined。NNN 是一个有符号的32位二进制补码表示的整数。数值参数通常是
一个整数。如果是大整数和浮点数，会被警告只有最低的32位会被使用，并且汇编器假装它们是32
位的整数。子表达式以左括号开始，跟随一个整型表达式，再加一个右括号；或者一个前缀操作符加
一个参数。

操作符是一种算术函数，例如 + 或者 % 操作符。前缀操作符后面会跟一个参数，中缀操作符位于
两个参数之间。操作符之前之后可以出现空白。有两个前缀操作符，负号（-）和位反（~），它们
之后跟随一个参数，这个参数必须是一个绝对值。

中缀操作符有两个参数，两边各一个。中缀操作符有优先级，如果优先级相同，使用从左到右的方式
进行结合。除了加号和减号，其他操作符的参数都必须是绝对值，结果也必须是绝对值。

1. 最高优先级：乘法（*），除法（/），取模（%），左移（<<），右移（>>）
2. 中等优先级：同或（|），位与（&），异或（^），或非（!）
3. 低等优先级：加法（+），减法（-），等于（==），不等于（<> 或 !=），大于（>），小于
   （<），大于等于（>=），小于等于（<=）；比较操作的结果是一个布尔值，结果值为 -1 表示
   真，结果值为 0 表示假，注意这些比较操作进行的是有符号比较
4. 最低优先级：逻辑与（&&），逻辑或（||）；不同于比较操作，该逻辑操作的结果值 1 表示
   真，结果值 0 表示假；另外，逻辑或的优先级比逻辑与低。

对于加法，如果任意一个参数是绝对值，最后的结果应该位于另一个参数的分区。不能对来自不同分
区的参数进行相加。对于减法，如果右参数是一个绝对值，最后的结果应该位于左参数的分区。如果
两个参数都位于同一个分区内，结果是绝对值。不能对来自不同分区的参数相减。简单来说，加法和
减法只能对一个地址加减偏移，两个参数中的一个只能有一个定义的分区。
